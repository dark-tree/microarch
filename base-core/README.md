# microarch BaseCore

**BaseCore** is a simple CPU core implementing the **microarch** ISA, designed in Verilog, with a testbench based on Verilator and SystemC.


##### Navigation

- ```README.md``` - You are here.
- ```Makefile``` - Build script for the project. See the **Building and running the testbench** section for details.
- ```tracedump/``` - Directory for trace files from testbench simulations in FST format (can be opened with GTKWave). NOTE: Trace files will only appear in the directory after building and running the testbench - they are not included in the git repository.
  - ```traces.fst``` - Trace file from the main testbench simulation.
  - ```traces_<module_name>_<test_name>.fst``` - Trace file from last execution of a specific test case.
- ```obj_dir/``` - Directory for temporary build files.
- ```design/``` - Directory for Verilog design files of the core itself.
  - ```flip_flop.v``` - A simple D flip-flop design, used to test the testbench.
  - ```alu.v``` - Design form the ALU.
- ```unit_tests.sh``` - A bash script for building and running tests for Verilog modules.
- ```testbench/``` - SystemC testbench for testing the core.
  - ```sc_main.cpp``` - Main testbench simulation - for ad-hoc development and testing of modules.
  - ```unit_tests/``` - Unit test system.
    - ```test_runner.h``` - A simple system for running unit tests.
    - ```tests/``` - Test files (one file per module)
      - ```sc_<module_name>.cpp``` - File with tests for a given module, for example ```sc_alu.cpp```.

##### Building and running the testbench

###### Dependencies:

- ```verilator```
- ```SystemC library from Accellera```
- ```make```
- ```GTKWave FlatPak package```
- ```g++ compiler```

###### Cleaning the build directory:

If something does not work, try a clean build by running ```make clean```

Note: this will delete all trace files from ```tracedump/```

###### Running the main simulation:

The main testbench simulation source is located in the  ```sc_main.cpp``` file (that's where you can manipulate the inputs).
To start it, execute:

```make run```

After the simulation completes, a ```GTKWave``` window will open (displaying traces, ie. a timeline of value changes on all inputs/outputs of the design).  Note: To see the traces you need to select the module from a drop-down menu on the left and then select I/O ports by double-clicking them.

###### Running unit tests:

To run all unit tests for all modules, for which there are unit tests, execute:

```make unit_tests```

You may also call the script directly to only invoke tests of a specific module:

```./unit_tests.sh design/my_module.v```

Information will be printed, on which tests passed and which did not pass.

You can view trace files generated by the tests with ```GTKWave```.
These files are located in the ```tracedump``` directory:

```traces_<module_name>_<test_name>.fst``` - Trace file from last execution of a specific test case.

To quickly launch ```GTKWave``` run:

```make waves```

Every Verilog module has to be in a separate design file to allow for testing it, as well as a separate test file.
For example: module named```alu```, should be in ```alu.v``` file in ```design/``` and it should have ```sc_alu.cpp```
test file in ```testbench/unit_tests/tests```. Otherwise ```unit_tests.sh``` script won't be able to find the files.

You can write your own test file. **Test file format:**

```
// Include the header file for your module  generated by Verilator. Format: V<module_name>.h
#include "Vmodule1.h"
// Include the unit test system
#include "test_runner.h"

TESTS;

  // Declaring a test:
  TEST(module1, my_test)
      // Creating a signal:
      SET_SIGNAL(signal_name);
      // Creating a signal with more than 1 bit:
      SET_SIGNAL_VECTOR(vector_name);
      // Optionally you may also create a clock - with period and delay in given in nanoseconds
      SET_CLOCK(my_clock, 10, 3);
      //Make sure, that clock and signal names match names from the Verilog module
  START_SIMULATION;
      // Assign binary value to a signal.
      signal_name = true;
      // Run simulation for a given number of nanoseconds.
      STEP(4);
      // Assert value of the 1-bit signal (if the assertion fails, the test will be marked as failed and failed assertion will be printed
      assert_signal(true, signal_name, "my nice assertion");
      assert_signal_vector(0b11010101, vector_name, "another nice assertion");
  END_SIMULATION;

 // Declaring another test:
  TEST(module1, another_test)
      // Initialize signals/clocks here
  START_SIMULATION;
      // Run the test here
  END_SIMULATION;

END_TESTS;
```
